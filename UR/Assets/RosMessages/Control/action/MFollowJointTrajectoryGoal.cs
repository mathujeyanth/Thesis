//Do not edit! This file was generated by Unity-ROS MessageGeneration.
using System;
using System.Linq;
using System.Collections.Generic;
using System.Text;
using Unity.Robotics.ROSTCPConnector.MessageGeneration;
using RosMessageTypes.Std;

namespace RosMessageTypes.Control
{
    public class MFollowJointTrajectoryGoal : Message
    {
        public const string RosMessageName = "control_msgs/FollowJointTrajectory";

        //  The joint trajectory to follow
        public Trajectory.MJointTrajectory trajectory;
        //  Tolerances for the trajectory.  If the measured joint values fall
        //  outside the tolerances the trajectory goal is aborted.  Any
        //  tolerances that are not specified (by being omitted or set to 0) are
        //  set to the defaults for the action server (often taken from the
        //  parameter server).
        //  Tolerances applied to the joints as the trajectory is executed.  If
        //  violated, the goal aborts with error_code set to
        //  PATH_TOLERANCE_VIOLATED.
        public MJointTolerance[] path_tolerance;
        //  To report success, the joints must be within goal_tolerance of the
        //  final trajectory value.  The goal must be achieved by time the
        //  trajectory ends plus goal_time_tolerance.  (goal_time_tolerance
        //  allows some leeway in time, so that the trajectory goal can still
        //  succeed even if the joints reach the goal some time after the
        //  precise end time of the trajectory).
        // 
        //  If the joints are not within goal_tolerance after "trajectory finish
        //  time" + goal_time_tolerance, the goal aborts with error_code set to
        //  GOAL_TOLERANCE_VIOLATED
        public MJointTolerance[] goal_tolerance;
        public MDuration goal_time_tolerance;

        public MFollowJointTrajectoryGoal()
        {
            this.trajectory = new Trajectory.MJointTrajectory();
            this.path_tolerance = new MJointTolerance[0];
            this.goal_tolerance = new MJointTolerance[0];
            this.goal_time_tolerance = new MDuration();
        }

        public MFollowJointTrajectoryGoal(Trajectory.MJointTrajectory trajectory, MJointTolerance[] path_tolerance, MJointTolerance[] goal_tolerance, MDuration goal_time_tolerance)
        {
            this.trajectory = trajectory;
            this.path_tolerance = path_tolerance;
            this.goal_tolerance = goal_tolerance;
            this.goal_time_tolerance = goal_time_tolerance;
        }
        public override List<byte[]> SerializationStatements()
        {
            var listOfSerializations = new List<byte[]>();
            listOfSerializations.AddRange(trajectory.SerializationStatements());
            
            listOfSerializations.Add(BitConverter.GetBytes(path_tolerance.Length));
            foreach(var entry in path_tolerance)
                listOfSerializations.Add(entry.Serialize());
            
            listOfSerializations.Add(BitConverter.GetBytes(goal_tolerance.Length));
            foreach(var entry in goal_tolerance)
                listOfSerializations.Add(entry.Serialize());
            listOfSerializations.AddRange(goal_time_tolerance.SerializationStatements());

            return listOfSerializations;
        }

        public override int Deserialize(byte[] data, int offset)
        {
            offset = this.trajectory.Deserialize(data, offset);
            
            var path_toleranceArrayLength = DeserializeLength(data, offset);
            offset += 4;
            this.path_tolerance= new MJointTolerance[path_toleranceArrayLength];
            for(var i = 0; i < path_toleranceArrayLength; i++)
            {
                this.path_tolerance[i] = new MJointTolerance();
                offset = this.path_tolerance[i].Deserialize(data, offset);
            }
            
            var goal_toleranceArrayLength = DeserializeLength(data, offset);
            offset += 4;
            this.goal_tolerance= new MJointTolerance[goal_toleranceArrayLength];
            for(var i = 0; i < goal_toleranceArrayLength; i++)
            {
                this.goal_tolerance[i] = new MJointTolerance();
                offset = this.goal_tolerance[i].Deserialize(data, offset);
            }
            offset = this.goal_time_tolerance.Deserialize(data, offset);

            return offset;
        }

        public override string ToString()
        {
            return "MFollowJointTrajectoryGoal: " +
            "\ntrajectory: " + trajectory.ToString() +
            "\npath_tolerance: " + System.String.Join(", ", path_tolerance.ToList()) +
            "\ngoal_tolerance: " + System.String.Join(", ", goal_tolerance.ToList()) +
            "\ngoal_time_tolerance: " + goal_time_tolerance.ToString();
        }
    }
}
